<?php
/**
 * @file
 * Content moderation.
 */

/**
 * Implements hook_autoload_info().
 */
function content_moderation_autoload_info() {
  return array(
    'content_moderation_handler_field_history_link' => 'includes/content_moderation_handler_field_history_link.inc',
    'content_moderation_handler_field_links' => 'includes/content_moderation_handler_field_links.inc',
    'content_moderation_handler_field_state' => 'includes/content_moderation_handler_field_state.inc',
    'content_moderation_handler_filter_state' => 'includes/content_moderation_handler_filter_state.inc',
    'content_moderation_handler_filter_moderated_type' => 'includes/content_moderation_handler_filter_moderated_type.inc',
    'content_moderation_handler_filter_user_can_moderate' => 'includes/content_moderation_handler_filter_user_can_moderate.inc',
    // 'ContentModerationMigrateDestinationHandler' => 'content_moderation.migrate.inc',
    'ContentModerationDraftTracker' => 'includes/ContentModerationDraftTracker.inc',
  );
}

/**
 * Implements hook_config_info().
 */
function content_moderation_config_info() {
  $prefixes['content_moderation.settings'] = array(
    'label' => t('Content Moderation settings'),
    'group' => t('Configuration'),
  );
  return $prefixes;
}

/**
 * Implements hook_menu().
 */
function content_moderation_menu() {
  $items = array();

  // Display a node's moderation history.
  $items["node/%node/moderation"] = array(
    'title' => 'Moderate',
    'description' => 'Show the content moderation history.',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'content_moderation_node_history_view',
    'page arguments' => array(1),
    'access callback' => '_content_moderation_access',
    'access arguments' => array('view history', 1),
    'file' => 'content_moderation.node.inc',
  );

  // Unpublishing a live revision.
  $items["node/%node/moderation/%/unpublish"] = array(
    'title' => 'Unpublish revision',
    'description' => 'Unpublish the current live revision.',
    'type' => MENU_CALLBACK,
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('content_moderation_node_unpublish_form', 1),
    'load arguments' => array(3),
    'access callback' => '_content_moderation_access',
    'access arguments' => array('unpublish', 1),
    'file' => 'content_moderation.node.inc',
  );

  // Change the moderation state of a node.
  // Used in content_moderation_get_moderation_links()
  $items["node/%node/moderation/%/change-state/%"] = array(
    'title' => 'Change moderation state',
    'page callback' => 'content_moderation_moderate_callback',
    'page arguments' => array(1, 5),
    'load arguments' => array(3),
    'access callback' => '_content_moderation_moderate_access',
    'access arguments' => array(1, 5),
    'type' => MENU_CALLBACK,
  );

  $items['node/%node/moderation/view'] = array(
    'title' => 'Revisions',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -1,
  );

  // View the active revision of a node. Redirects to node/%node if the active
  // revision is published, and to node/%node/draft if the active revision is
  // a draft.
  $items["node/%node/active-revision"] = array(
    'page callback' => 'content_moderation_node_current_view',
    'page arguments' => array(1),
    'access arguments' => array('access content'),
    'file' => 'content_moderation.node.inc',
  );

  // View the current draft of a node.
  $items["node/%node/draft"] = array(
    'title' => 'View draft',
    'page callback' => 'content_moderation_node_view_draft',
    'page arguments' => array(1),
    'access callback' => '_content_moderation_access_current_draft',
    'access arguments' => array(1),
    'file' => 'content_moderation.node.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => -9,
  );

  // Module settings.
  $items["admin/config/content/moderation"] = array(
    'title' => 'Content Moderation',
    'description' => 'Configure content moderation.',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('content_moderation_admin_states_form'),
    'access arguments' => array('administer content moderation'),
    'file' => 'content_moderation.admin.inc',
  );
  $items['admin/config/content/moderation/general'] = array(
    'title' => 'States',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -1,
  );
  $items['admin/config/content/moderation/transitions'] = array(
    'title' => 'Transitions',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('content_moderation_admin_transitions_form'),
    'access arguments' => array('administer content moderation'),
    'file' => 'content_moderation.admin.inc',
  );
  $items['admin/config/content/moderation/check-permissions'] = array(
    'title' => 'Check permissions',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('content_moderation_admin_check_role_form'),
    'access arguments' => array('administer content moderation'),
    'file' => 'content_moderation.admin.inc',
    'weight' => 10,
  );

  // If the diff module is present, replicate its pages under the moderation
  // tab.
  if (module_exists('diff')) {
    $diff_menu_items  = diff_menu();

    $items['node/%node/moderation/diff'] = array(
      'type' => MENU_LOCAL_TASK,
      'file path' => backdrop_get_path('module', 'diff'),
      'title' => 'Compare revisions',
      'page arguments' => array(1),
    );

    $items['node/%node/moderation/diff'] += $diff_menu_items['node/%node/revisions/list'];

    $items['node/%node/moderation/diff/list'] = array(
      'title' => 'Compare revisions',
      'type' => MENU_DEFAULT_LOCAL_TASK,
      'weight' => -1,
    );

    $items['node/%node/moderation/diff/view'] = array(
      'page arguments' => array(1, 5, 6),
      'tab_parent' => 'node/%/moderation/diff/list',
      'file path' => backdrop_get_path('module', 'diff'),
    );

    $items['node/%node/moderation/diff/view'] += $diff_menu_items['node/%node/revisions/view'];
  }

  return $items;
}


/**
 * Implements hook_form_FORM_ID_alter().
 */
function content_moderation_form_diff_node_revisions_alter(&$form, &$form_state, $form_id) {

  // If this form is appearing under moderation then add a submit function
  // that will keep the user in the moderation tab.
  if (arg(2) == 'moderation') {
    $form['#submit'][] = 'content_moderation_diff_node_revisions_submit';
  }
}

/**
 * Redirects the the diff_node_revisions form when the user is under the
 * moderation tab.
 */
function content_moderation_diff_node_revisions_submit($form, &$form_state) {

  // The ids are ordered so the old revision is always on the left.
  $old_vid = min($form_state['values']['old'], $form_state['values']['new']);
  $new_vid = max($form_state['values']['old'], $form_state['values']['new']);
  $form_state['redirect'] = 'node/'. $form_state['values']['nid'] .'/moderation/diff/view/'. $old_vid .'/'. $new_vid;
}

/**
 * Implements hook_menu_alter().
 */
function content_moderation_menu_alter(&$items) {
  // Hijack the node/X/edit page to ensure that the right revision (most
  // current) is displayed.
  $items['node/%node/edit']['page callback'] = 'content_moderation_node_edit_page_override';

  // Override the node edit menu item title.
  $items['node/%node/edit']['title callback'] = 'content_moderation_edit_tab_title';
  $items['node/%node/edit']['title arguments'] = array(1);

  // Override the node view menu item title.
  $items['node/%node/view']['title callback'] = 'content_moderation_view_tab_title';
  $items['node/%node/view']['title arguments'] = array(1);

  // Redirect node/%node/revisions.
  $items['node/%node/revisions']['page callback'] = 'content_moderation_node_revisions_redirect';
  $items['node/%node/revisions']['page arguments'] = array(1);

  // Override the node revision view callback.
  $items['node/%node/revisions/%/view']['page callback'] = 'content_moderation_node_view_revision';
  $items['node/%node/revisions/%/view']['file path'] = backdrop_get_path('module', 'content_moderation');
  $items['node/%node/revisions/%/view']['file'] = 'content_moderation.node.inc';

  // For revert and delete operations, use our own access check.
  $items['node/%node/revisions/%/revert']['access callback'] = '_content_moderation_revision_access';
  $items['node/%node/revisions/%/revert']['access arguments'] = array(
    1,
    'update',
  );
  $items['node/%node/revisions/%/delete']['access callback'] = '_content_moderation_revision_access';
  $items['node/%node/revisions/%/delete']['access arguments'] = array(
    1,
    'delete',
  );

  // Provide a container administration menu item, if one doesn't already exist.
  if (!isset($items['admin/config/content'])) {
    $items['admin/config/content'] = array(
      'title' => 'Content Moderation',
      'description' => 'Content moderation',
      'page callback' => 'system_admin_menu_block_page',
      'access arguments' => array('administer site configuration'),
      'position' => 'right',
      'file' => 'system.admin.inc',
      'file path' => backdrop_get_path('module', 'system'),
    );
  }
}

/**
 * Redirects 'node/%node/revisions' to node/%node/moderation
 *
 * content_moderation_menu_alter() changes the page callback
 * for 'node/%node/revisions' to this function.
 *
 * @param Node $node
 *   The node being acted upon.
 */
function content_moderation_node_revisions_redirect(Node $node) {
  // Redirect nodes subject to moderation.
  if (content_moderation_node_moderated($node) === TRUE) {
    backdrop_goto('node/' . $node->nid . '/moderation');
  }
  // Return the normal node revisions page for unmoderated types.
  else {

    if (module_exists('diff')) {
      return diff_diffs_overview($node);
    }
    else {
      return node_revision_overview($node);
    }
  }
}

/**
 * Implements hook_menu_local_tasks_alter().
 *
 * Hide the node revisions tab conditionally.
 *
 * Check if the node type is subject to moderation. If so, unset the revision
 * tab. This step is necessary because hook_menu_alter cannot change the menu
 * item type on a node type by node type basis for node/%node/revision.
 *
 * Additionally, content_menu_alter() is used to change the page callback
 * for node/%node/revisions so that this URL redirects to node/%node/moderation
 * for node types subject to moderation.
 */
function content_moderation_menu_local_tasks_alter(&$data, $router_item, $root_path) {
  // Do we need to bother doing anything?
  if (empty($data['tabs'][0]['output'])) {
    return;
  }

  // Check the path.
  $arg = arg(0, $root_path);
  $arg1 = arg(1, $root_path);
  if ($arg != 'node' || $arg1 != '%') {
    return;
  }

  // Get the node for the current menu router.
  if ($node = menu_get_object()) {
    // Here is the reason this hook implementation exists:
    // If this is a node that gets moderated, don't show 'node/%/revisions'.
    if (content_moderation_node_moderated($node) === TRUE) {
      foreach ($data['tabs'][0]['output'] as $key => $value) {
        if (!empty($value['#link']['path']) && $value['#link']['path'] == 'node/%/revisions') {
          unset($data['tabs'][0]['output'][$key]);
          $data['tabs'][0]['count'] -= 1;
          break;
        }
      }
    }
  }
}

/**
 * Change the name of the node edit tab, conditionally.
 *
 * - Don't change the title if the content is not under moderation.
 *
 * - If a piece of content has a published revision and the published revision
 *   is also the current moderation revision, the "Edit" tab should be titled
 *   "Create draft".
 *
 * - If a piece of content has a published revision and the current moderation
 *   revision is a newer, or if the content has no published revision, the
 *   "Edit" tab should be titled "Edit draft".
 *
 * @param Node $node
 *   The node being acted upon.
 *
 * @return string
 *   The title for the tab.
 */
function content_moderation_edit_tab_title(Node $node) {
  // Use the normal tab title if the node is not under moderation.
  if (!content_moderation_node_moderated($node)) {
    return t('Edit');
  }

  // Is the latest draft published?
  $state = $node->content_moderation;
  if (!empty($state['published']) && $state['published']->vid == $state['current']->vid) {
    return t('New draft');
  }

  // The latest draft is not published.
  return t('Edit draft');
}

/**
 * Change the name of the node view tab, conditionally.
 *
 * - Don't change the title if the content is not under moderation.
 *
 * - If a piece of content has a published revision, the "View" tab should be
 *   titled "View published".
 *
 * - Otherwise, it should be titled "View draft".
 *
 * @param Node $node
 *   The node being acted upon.
 *
 * @return string
 *   The title for the tab.
 */
function content_moderation_view_tab_title(Node $node) {
  // Use the normal tab title if the node is not under moderation.
  if (!content_moderation_node_moderated($node)) {
    return t('View');
  }

  // Is there a published revision?
  $state = $node->content_moderation;
  if (!empty($state['published'])) {
    return t('View published');
  }
  return t('View draft');
}


/**
 * Implements hook_admin_paths().
 */
function content_moderation_admin_paths() {
  if (config_get('system.core', 'admin_theme')) {
    $paths = array(
      'node/*/moderation' => TRUE,
      'node/*/moderation/*/unpublish' => TRUE,
      'node/*/moderation/*/change-state/*' => TRUE,
      'node/*/moderation/view' => TRUE,
      'node/*/moderation/diff' => TRUE,
      'node/*/moderation/diff/list' => TRUE,
      'node/*/moderation/diff/view' => TRUE,
      'node/*/moderation/diff/view/*/*' => TRUE,
    );
    return $paths;
  }
}

/**
 * Implements hook_theme().
 */
function content_moderation_theme() {
  return array(
    'content_moderation_admin_states_form' => array(
      'file' => 'content_moderation.admin.inc',
      'render element' => 'form',
    ),
    'content_moderation_admin_transitions_form' => array(
      'file' => 'content_moderation.admin.inc',
      'render element' => 'form',
    ),
  );
}

/**
 * Implements hook_permission().
 *
 * Provides permissions for each state to state change.
 */
function content_moderation_permission() {
  $permissions = array();
  $permissions['view all unpublished content'] = array(
    'title' => t('View all unpublished content'),
  );
  $permissions['administer content moderation'] = array(
    'title' => t('Administer Content Moderation'),
  );
  $permissions['bypass content moderation'] = array(
    'title' => t('Bypass moderation restrictions'),
    'restrict access' => TRUE,
  );
  $permissions['view moderation history'] = array(
    'title' => t('View moderation history'),
  );
  $permissions['view moderation messages'] = array(
    'title' => t('View the moderation messages on a node'),
  );
  $permissions['use content_moderation my drafts tab'] = array(
    'title' => t('Use "My drafts" content tab'),
  );
  $permissions['use content_moderation needs review tab'] = array(
    'title' => t('Use "Needs review" content tab'),
  );

  // Per-node-type, per-transition permissions. Used by
  // content_moderation_state_allowed().
  $node_types = content_moderation_moderate_node_types();
  $transitions = content_moderation_transitions();

  foreach ($transitions as $transition) {
    $from_state = $transition['from_name'];
    $to_state = $transition['to_name'];

    // Always set a permission to perform all moderation states.
    $permissions["moderate content from $from_state to $to_state"] = array(
      'title' => t('Moderate all content from %from_state to %to_state', array(
        '%from_state' => content_moderation_state_label($from_state),
        '%to_state' => content_moderation_state_label($to_state),
      )),
    );
    // Per-node type permissions are very complex, and should only be used if
    // absolutely needed. For right now, this is hardcoded to OFF. To enable it,
    // Add this line to settings.php and then reset permissions:
    // $settings['content_moderation_per_node_type'] = TRUE; // Permissions.
    if (settings_get('content_moderation_per_node_type', FALSE)) {
      foreach ($node_types as $node_type) {
        $permissions["moderate $node_type state from $from_state to $to_state"] = array(
          'title' => t('Moderate %node_type state from %from_state to %to_state', array(
            '%node_type' => node_type_get_name($node_type),
            '%from_state' => content_moderation_state_label($from_state),
            '%to_state' => content_moderation_state_label($to_state),
          )),
        );
      }
    }
  }
  return $permissions;
}

/**
 * Implements hook_node_access().
 *
 * Allows users with the 'view all unpublished content' permission to do so.
 */
function content_moderation_node_access($node, $op, $account) {
  if ($op == 'view' && !$node->status && user_access('view all unpublished content', $account)) {
    return NODE_ACCESS_ALLOW;
  }
  return NODE_ACCESS_IGNORE;
}

/**
 * Custom access handler for node operations.
 *
 * @param string $op
 *   The operation being requested.
 * @param Node $node
 *   The node being acted upon.
 *
 * @return bool
 *   TRUE or FALSE.
 */
function _content_moderation_access($op, Node $node) {
  global $user;

  // If we do not control this node type, deny access.
  if (content_moderation_node_type_moderated($node->type) === FALSE) {
    return FALSE;
  }

  $access = TRUE;

  // The user must be able to view the moderation history.
  $access &= user_access('view moderation history');

  // The user must be able to edit this node.
  $access &= node_access('update', $node);

  if ($op == 'unpublish') {
    // content_moderation_states_next() checks transition permissions.
    $next_states = content_moderation_states_next(content_moderation_state_published(), $user, $node);
    $access &= !empty($next_states);
  }

  // Allow other modules to change our rule set.
  backdrop_alter('content_moderation_access', $access, $op, $node);

  return $access;
}

/**
 * Wrapper for the 'revert' and 'delete' operations of _node_revision_access().
 *
 * Backdrop core's "active revision" of a node is the version in {node}; for
 * Content Moderation, latest revision in {node_revision} is the current
 * revision. For nodes with a published revision, Content Moderation keeps
 * that revision in {node}, whether or not it is the active revision.
 *
 * @param Node $node
 *   The node being acted on.
 * @param string $op
 *   The operation being requested.
 */
function _content_moderation_revision_access(Node $node, $op) {
  // Normal behavior for unmoderated nodes.
  if (!content_moderation_node_moderated($node)) {
    return _node_revision_access($node, $op);
  }

  // Prevent reverting to (ie, update) the active revision.
  if ($node->content_moderation['current']->vid == $node->content_moderation['my_revision']->vid) {
    if ($op == 'update') {
      return FALSE;
    }
  }
  // Prevent deleting the active revision, if there is no separate published
  // revision. This also prevents deleting the active revision if it is the
  // only revision, and its unpublished.
  $is_active_revision = $node->isActiveRevision();
  if ($node->content_moderation['current']->vid == $node->content_moderation['my_revision']->vid) {
    if ($op == 'delete' && !isset($node->content_moderation['published'])) {
      // In theory, deleting the one and only revision of a node could be
      // allowed but we'd need to add special logic that actually deletes
      // the node, not just the revision.
      return FALSE;
    }
  }
  // Prevent deleting a published revision.
  if (isset($node->content_moderation['published']) && $node->content_moderation['published']->vid == $node->content_moderation['my_revision']->vid) {
    if ($op == 'delete') {
      // In theory, deleting a published revision could be allowed but we'd
      // need to solve the problem of determining what to do if you delete the
      // published revision, e.g., what database tables and fields would need
      // to be cascaded for such a change.
      return FALSE;
    }
  }

  // Check access.
  return _node_revision_access($node, $op);
}

/**
 * Checks if a user may make a particular transition on a node.
 *
 * @param Node $node
 *   The node being acted upon.
 * @param string $state
 *   The new moderation state.
 *
 * @return bool
 *   Booelan TRUE or FALSE.
 */
function _content_moderation_moderate_access(Node $node, $state) {
  global $user;

  $my_revision = $node->content_moderation['my_revision'];
  $next_states = content_moderation_states_next($my_revision->state, $user, $node);
  // Determining node access:
  // - The user can edit the node.
  // - This is the active revision (no branching the revision history).
  // - There are next states the user may transition to.
  // - This state is in the available next states.
  $access = node_access('update', $node, $user)
          && $my_revision->is_current
          && (!empty($next_states))
          && isset($next_states[$state]);

  // Allow other modules to change our rule set.
  $op = 'moderate';
  backdrop_alter('content_moderation_access', $access, $op, $node);

  return $access;
}

/**
 * Checks if the user can view the current node revision.
 *
 * This is the access callback for node/%node/draft as defined in
 * content_moderation_menu().
 *
 * @param Node $node
 *   The node being acted upon.
 *
 * @return bool
 *   TRUE or FALSE.
 */
function _content_moderation_access_current_draft(Node $node) {

  // This tab should only appear for nodes under moderation.
  if (!content_moderation_node_moderated($node)) {
    return FALSE;
  }

  $state = $node->content_moderation;

  return (_content_moderation_access('view revisions', $node)
      && !empty($state['published'])
      && $state['published']->vid != $state['current']->vid);
}

/**
 * Implements hook_help().
 */
function content_moderation_help($path, $arg) {
  switch ($path) {
    case 'admin/help#content_moderation':
      return '<p>' . t("Enables you to control node display with a moderation workflow. You can have a 'Live revision' for all visitors and pending revisions which need to be approved to become the new 'Live revision.'") . '</p>';

    case 'admin/config/content/moderation':
      return '<p>' . t("These are the states through which a node passes in order to become published. By default, the Content Moderation module provides the states 'Draft,' 'Needs review,' and 'Published'. On this screen you may create, delete and re-order states. Additional states might include 'Legal review,' 'PR review', or any or state your site may need.") . '</p>';

    case 'admin/config/content/moderation/transitions':
      return '<p>' . t('The Content Moderation module keeps track of when a node moves from one state to another. By default, nodes begin in the %draft state and end in the %published state. The transitions on this page control how nodes move from state to state. <a href="@permissions">Permission to perform these transitions is controlled on a role-by-role basis</a>.',
        array(
          '%draft' => content_moderation_state_label(content_moderation_state_none()),
          '%published' => content_moderation_state_label(content_moderation_state_published()),
          '@permissions' => url('admin/people/permissions',
            array(
              'fragment' => 'module-content_moderation',
            ),
          ),
        )
      ) . '</p>';

    case 'admin/config/content/moderation/check-permissions':
      return '<p>' . t("In order to participate in the moderation process, Backdrop users must be granted several node- and moderation- related permissions. This page can help check whether roles have the correct permissions to author, edit, moderate, and publish moderated content.") . '</p>';
  }
}

/**
 * Implements hook_views_api().
 */
function content_moderation_views_api() {
  return array('api' => 2.0);
}

/**
 * Implements hook_entity_presave().
 */
function content_moderation_entity_presave($entity, $entity_type) {
  // Note: this only supports nodes at the moment.
  if ($entity_type != 'node') {
    return;
  }
  // Is the content type under moderation?
  if (!content_moderation_node_type_moderated($entity->type)) {
    return;
  }

  // Load our data onto the entity.
  if (!$entity->isNew()) {
    content_moderation_set_node_state($entity);
  }

  $published = FALSE;
  // Ensure the entity is marked as published.
  if (isset($entity->content_moderation_state_new) && $entity->content_moderation_state_new == content_moderation_state_published()) {
    $published = TRUE;
    $entity->status = NODE_PUBLISHED;
  }

  // If we are unpublishing a node, do not force revision.
  if (!$entity->status) {
    $entity->is_active_revision = TRUE;
  }

  // Inform if this is a new revision, if it has not already been
  // marked as such.
  elseif (!isset($entity->is_active_revision) && !$published) {
    $entity->is_active_revision = TRUE;
  }

  // @todo only do so if core setting is "Save as draft" or override it?
  if (!$published) {
    $entity->status = NODE_NOT_PUBLISHED;
  }

  $recursion_level = &backdrop_static('content_moderation_recursion_level', 0);
  if (!$recursion_level && !$entity->isNew() && !$entity->is_active_revision) {
    // Since this is a draft revision, after saving we want the current,
    // published revision to remain in place in the base entity table and
    // field_data_*() tables. Set the revision to publish once the draft entity
    // has been written to the database.
    $id = $entity->id();
    $type = $entity->entityType();
    $vid = draft_tracker()->getPublishedRevisionId($type, $id);
    // $vid = $entity->getRevisionId(); (or use this?)
    draft_tracker()->setRevisionToBePublished($type, $id, $vid);
  }
  $recursion_level++;

}

/**
 * Implements hook_entity_update().
 */
function content_moderation_entity_update($entity, $type) {
  $recursion_level = &backdrop_static('content_moderation_recursion_level', 0);
  if ($recursion_level == 1) {
    // Doing this in hook_entity_update() so that the entire process is
    // completed within entity saving. However this results in two entity saves
    // within entity insert. The other option is hook_exit(), which is not
    // better since for example that would happen outside the transaction.
    draft_tracker()->restorePublishedRevisions();
  }
  $recursion_level--;
}

/**
 * Implements hook_entity_insert().
 */
function content_moderation_entity_insert($entity, $type) {
  $recursion_level = &backdrop_static('content_moderation_recursion_level', 0);
  $recursion_level--;
}

/**
 * Implements hook_field_attach_load().
 */
function content_moderation_field_attach_load($entity_type, $entities, $age, $options) {
  // Entity API provides the function entity_revision_is_default() to determine
  // whether an entity was loaded with the default revision or not. However this
  // is not sufficient for two reasons.
  //  - It relies on entity_load() for core entities, which makes it unsafe to
  //    call within hook_entity_load() implementations. This can be useful when
  //    allowing drafts to be previewed in context such as listings.
  //  - The entity API implementation only tells you whether the entity was
  //    loaded with that revision or not, but not whether it was requested
  //    with the ID or with the revision explicitly specified.

  // Note that hook_field_attach_load() is the only hook in core where it is
  // possible to determine whether calling code requested a revision or not,
  // this information is not available to hook_entity_load(). Also note that
  // hook_field_attach_load() is cached when entities are loaded only be ID, but
  // since revision loads don't use the field cache it works fine for our
  // purposes.
  foreach ($entities as $entity) {
    $entity->content_moderation_revision_requested = $age;
  }
}

/**
 * Implements hook_node_insert().
 *
 * Store moderation data for this node.
 */
function content_moderation_node_insert($node) {
  content_moderation_save($node);
}

/**
 * Loads moderation information onto a node being saved.
 *
 * @param Node $node
 *   The node being acted on.
 */
function content_moderation_set_node_state(Node $node) {
  global $user;

  // Set moderation state values.
  if (!isset($node->content_moderation_state_current)) {
    $node->content_moderation_state_current = !empty($node->original->content_moderation['current']->state) ? $node->original->content_moderation['current']->state : content_moderation_state_none();
  }
  if (!isset($node->content_moderation_state_new)) {
    $default_state = config_get('node.type.' . $node->type, 'settings.content_moderation_default_state');
    // Moderating the default revision.
    if (!empty($node->isActiveRevision()) && $node->status) {
      $node->content_moderation_state_new = content_moderation_state_published();
    }
    // Moving from published to unpublished.
    elseif ($node->status == NODE_NOT_PUBLISHED && isset($node->original->status) && $node->original->status == NODE_PUBLISHED) {
      // @todo Currently we cannot set the state correctly if the default state
      //   is "Published".
      // @see https://www.drupal.org/node/1436260
      $node->content_moderation_state_new = ($default_state == NULL) ?  content_moderation_state_none() : $default_state;
    }
    // Moving from unpublished to published.
    elseif ($node->status == NODE_PUBLISHED && isset($node->original->status) && $node->original->status == NODE_NOT_PUBLISHED) {
      $node->content_moderation_state_new = content_moderation_state_published();
    }
    else {
      if (!empty($node->original->content_moderation['current']->state)) {
        $node->content_moderation_state_new = $node->original->content_moderation['current']->state;
      }
      else {
        $node->content_moderation_state_new = ($default_state == NULL) ?  content_moderation_state_none() : $default_state;
      }
    }
  }

  // If this is a new node, give it some information about 'my revision'.
  if (!isset($node->content_moderation)) {
    $node->content_moderation = array();
    $node->content_moderation['my_revision'] = $node->content_moderation['current'] = (object) array(
      'from_state' => content_moderation_state_none(),
      'state' => content_moderation_state_none(),
      'nid' => $node->nid,
      'vid' => $node->vid,
      'uid' => $user->uid,
      'is_current' => TRUE,
      'published' => FALSE,
      'stamp' => $node->changed,
    );
  }
}

/**
 * Implements hook_node_update().
 *
 * Stores the moderation information for this node.
 */
function content_moderation_node_update($node) {
  content_moderation_save($node);
}

/**
 * Saves the moderation history for the node.
 *
 * @param Node $node
 *   The node being acted on.
 */
function content_moderation_save(Node $node) {
  $current_draft = &backdrop_static(__FUNCTION__, 0);
  global $user;

  // Don't proceed if moderation is not enabled on this content.
  if (!content_moderation_node_moderated($node)) {
    return;
  }
  // Ensure that we have loaded our data onto the node. This function will
  // check that the required properties are set for all nodes.
  content_moderation_set_node_state($node);

  // Prepare the state information.
  $state = $node->content_moderation_state_new;
  $old_revision = $node->content_moderation['my_revision'];

  if (empty($node->isActiveRevision())) {
    $node->setIsActiveRevision();
  }

  // Build a history record.
  $new_revision = (object) array(
    'from_state' => $old_revision->state,
    'state' => $state,
    'nid' => $node->nid,
    'vid' => $node->vid,
    'uid' => $user->uid,
    'is_current' => !empty($node->isActiveRevision()),
    'published' => ($state == content_moderation_state_published()),
    'stamp' => $_SERVER['REQUEST_TIME'],
  );

  // If this is the new 'current' moderation record, it should be the only one
  // flagged 'current' in {content_moderation_node_history}.
  if ($new_revision->is_current) {
    $query = db_update('content_moderation_node_history')
      ->condition('nid', $node->nid)
      ->fields(array('is_current' => 0))
      ->execute();
  }

  // If this revision is to be published, the new moderation record should be
  // the only one flagged 'published' in {content_moderation_node_history}.
  // Also applies in the case where we unpublish a live revision.
  if ($new_revision->published || !$node->status) {
    $query = db_update('content_moderation_node_history')
      ->condition('nid', $node->nid)
      ->fields(array('published' => 0))
      ->execute();
  }

  // Save the node history record.
  backdrop_write_record('content_moderation_node_history', $new_revision);

  // On a moderation loop, inform other modules of the change.
  if (!empty($node->isActiveRevision())) {
    // Clear the node's cache.
    entity_get_controller('node')->resetCache(array($node->nid));

    // Notify other modules that the state was changed.
    module_invoke_all('content_moderation_transition', $node, $node->content_moderation['my_revision']->state, $node->content_moderation_state_new);
  }
}

/**
 * Implements hook_node_load().
 *
 * Load moderation history and status on a node.
 */
function content_moderation_node_load($nodes, $types) {
  foreach ($nodes as $node) {
    // Add the node history.
    content_moderation_node_data($node);
  }
}

/**
 * Implements hook_node_view().
 *
 * Display messages about the node's moderation state.
 */
function content_moderation_node_view($node, $view_mode = 'full') {
  // Show moderation state messages if we're on a node page.
  if (node_is_page($node) && $view_mode == 'full' && empty($node->in_preview)) {
    content_moderation_messages('view', $node);
  }
}

/**
 * Implements hook_node_delete().
 */
function content_moderation_node_delete($node) {
  // Delete node history when it is deleted.
  db_delete('content_moderation_node_history')
    ->condition('nid', $node->nid)
    ->execute();
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Add moderation rules to node types.
 */
function content_moderation_form_node_type_form_alter(&$form, $form_state) {
  $node_type = $form['#node_type'];
  // Get a list of moderation states.
  $options = content_moderation_state_labels();

  // Disable the 'revision' checkbox when the 'moderation' checkbox is checked,
  // so that moderation can not be enabled unless revisions are enabled.
  $form['revision']['revision']['revision_enabled']['#states'] = array(
    'disabled' => array(':input[name="moderation_enabled"]' => array('checked' => TRUE)),
  );

  $form['content_moderation'] = array(
    '#type' => 'fieldset',
    '#title' => t('Moderation'),
    '#group' => 'additional_settings',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#access' => user_access('administer content moderation'),
    '#attached' => array(
      'js' => array(backdrop_get_path('module', 'content_moderation') . '/js/content_moderation.js'),
    ),
  );

  // Disable the 'moderation' checkbox when the 'revision' checkbox is not
  // checked, so that revisions can not be turned off without also turning off
  // moderation.
  $form['content_moderation']['moderation_enabled'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable moderation of revisions'),
    '#default_value' => !isset($node_type->settings['moderation_enabled']) ? 0 : $node_type->settings['moderation_enabled'],
    '#description' => t('Revisions must be enabled in order to use moderation.'),
    '#states' => array(
      'disabled' => array(
        ':input[name="revision_enabled"]' => array(
          'checked' => FALSE,
        ),
      ),
    ),
  );

  // This select element is hidden when moderation is not enabled.
  $form['content_moderation']['content_moderation_default_state'] = array(
    '#title' => t('Default moderation state'),
    '#type' => 'select',
    '#options' => $options,
    '#default_value' => !isset($node_type->settings['content_moderation_default_state']) ? NULL : $node_type->settings['content_moderation_default_state'],
    '#description' => t('Set the default moderation state for this content type. Users with additional moderation permissions will be able to set the moderation state when creating or editing nodes.'),
    '#states' => array(
      'visible' => array(':input[name="moderation_enabled"]' => array('checked' => TRUE)),
    ),
  );
  $form['#validate'][] = 'content_moderation_node_type_form_validate';
  $form['#submit'][] = 'content_moderation_node_type_form_submit';
}

/**
 * Validate the content type form.
 */
function content_moderation_node_type_form_validate($form, &$form_state) {
  // Ensure that revisions are enabled if moderation is.
  if ($form_state['values']['moderation_enabled']) {
    $form_state['values']['status_default'] = 0;
    $form_state['values']['revision_enabled'] = 1;
  }
}

/**
 * Submit handler for node type form.
 */
function content_moderation_node_type_form_submit($form, &$form_state) {
  if (isset($form_state['values']['moderation_enabled'])) {
    $config = config('node.type.' . $form_state['values']['type']);
    $config->set('settings.moderation_enabled', $form_state['values']['moderation_enabled']);
    $config->set('settings.content_moderation_default_state', $form_state['values']['content_moderation_default_state']);
    $config->save();
  }
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 *
 * Forcing new reversion and publishing.
 */
function content_moderation_form_node_form_alter(&$form, $form_state) {
  global $user;

  // This must be a node form and a node that has moderation enabled.
  // Extended to include moderation check on the individual node.
  if (!content_moderation_node_moderated($form['#node'])) {
    return;
  }

  // Set a moderation state even if there is not one defined.
  if (isset($form['#node']->content_moderation['current']->state)) {
    $moderation_state = $form['#node']->content_moderation['current']->state;
  }
  else {
    $moderation_state = content_moderation_state_none();
  }

  // Store the current moderation state.
  $form['content_moderation_state_current'] = array(
    '#type' => 'value',
    '#value' => $moderation_state,
  );

  // We have a use case where a published node is being edited. This will always
  // revert back to the original node status.
  if ($moderation_state == content_moderation_state_published()) {
    $moderation_state = content_moderation_state_none();
  }

  // Get all the states *this* user can access. If there aren't any, this user
  // can not change the moderation state.
  if ($states = content_moderation_states_next($moderation_state, $user, $form['#node'])) {
    $states[$moderation_state] = t('@state (Current)', array('@state' => content_moderation_state_label($moderation_state)));
    $states_sorted = array();
    foreach (array_keys(content_moderation_states()) as $state) {
      if (array_key_exists($state, $states)) {
        $states_sorted[$state] = $states[$state];
      }
    }
    $states = $states_sorted;

    $form['revision_information']['content_moderation_state_new'] = array(
      '#title' => t('Moderation state'),
      '#type' => 'select',
      '#options' => $states,
      '#description' => t('Set the moderation state for this content.'),
      '#access' => $states ? TRUE : FALSE,
    );

    // If the user has access to the pre-set default state, make it the default
    // here. Otherwise, don't set a default in this case.
    $default_state = config_get('node.type.' . $form['type']['#value'], 'settings.content_moderation_default_state');
    if ($default_state && array_key_exists($default_state, $states)) {
      $form['revision_information']['content_moderation_state_new']['#default_value'] = $default_state;
    }
    else {
      $form['revision_information']['content_moderation_state_new']['#default_value'] = content_moderation_state_none();
    }
  }
  else {
    // Store the current moderation state.
    $form['content_moderation_state_new'] = array(
      '#type' => 'value',
      '#value' => $moderation_state,
    );
  }

  // Always create new revisions for nodes that are moderated.
  $form['revision_information']['revision'] = array(
    '#type' => 'value',
    '#value' => TRUE,
  );

  // Set a default revision log message.
  $logged_name = (user_is_anonymous() ? config_get('site.core', 'anonymous') : user_format_name($user));
  if (!empty($form['#node']->nid)) {
    $form['revision_information']['log']['#default_value'] = t('Edited by !user.', array('!user' => $logged_name));
  }
  else {
    $form['revision_information']['log']['#default_value'] = t('Created by !user.', array('!user' => $logged_name));
  }

  // Move the revision log into the publishing options to make things pretty.
  if ($form['options']['#access']) {
    $form['options']['log'] = $form['revision_information']['log'];
    $form['options']['log']['#title'] = t('Moderation notes');
    $form['options']['content_moderation_state_new'] = isset($form['revision_information']['content_moderation_state_new']) ? $form['revision_information']['content_moderation_state_new'] : array();

    // Unset the old placement of the Revision log.
    unset($form['revision_information']['log']);
    unset($form['revision_information']['content_moderation_state_new']);

    // The revision information section should now be empty.
    $form['revision_information']['#access'] = FALSE;
  }

  // @todo make this part work again.
  // Setup the JS for the vertical tabs summary. The heavy weight allows this
  // script to replace the default node summary callbacks that get registered by
  // "lighter" scripts.
  // Note: Form API '#attached' does not allow to set a weight.
  backdrop_add_js(backdrop_get_path('module', 'content_moderation') . '/js/content_moderation.js', array('weight' => 90));

  // Users can not choose to publish content; content can only be published by
  // setting the content's moderation state to "Published".
  $form['options']['status']['#access'] = FALSE;
  $form['actions']['submit']['#submit'][] = 'content_moderation_node_form_submit';
  content_moderation_messages('edit', $form['#node']);
}

/**
 * Redirect to the active revision of a node after editing.
 */
function content_moderation_node_form_submit($form, &$form_state) {
  $form_state['redirect'] = array('node/' . $form_state['node']->nid . '/active-revision');
}

/**
 * Overrides the node/%/edit page to ensure the proper revision is shown.
 *
 * @param Node $node
 *   The node being acted upon.
 * @return array
 *   A node editing form.
 */
function content_moderation_node_edit_page_override(Node $node) {
  // Check to see if this is an existing node.
  if (isset($node->nid)) {
    if (content_moderation_node_type_moderated($node->type)) {
      // Load the node moderation data.
      content_moderation_node_data($node);
      // We ONLY edit the active revision.
      $node = content_moderation_node_current_load($node);
    }
  }
  // Ensure we have the editing code.
  module_load_include('inc', 'node', 'node.pages');
  return node_page_edit($node);
}

/**
 * Returns the key which represents the live revision.
 *
 * @TODO: make this configurable.
 */
function content_moderation_state_published() {
  return 'published';
}

/**
 * Returns the key which represents the neutral non moderated revision.
 *
 * @TODO: make this configurable.
 */
function content_moderation_state_none() {
  return 'draft';
}

/**
 * Determines if this content type is set to be moderated
 *
 * @param string $type
 *   Content type name.
 *
 * @return bool
 */
function content_moderation_node_type_moderated($type) {
  // Is this content even in moderatation?
  return config_get('node.type.' . $type, 'settings.moderation_enabled');
}

/**
 * Determines if this content is set to be moderated.
 *
 * @param Node $node
 *   Node object.
 *
 * @return bool
 *   TRUE if content is set to be moderated, FALSE otherwise.
 */
function content_moderation_node_moderated(Node $node) {
  // Is this content moderated? (individual node check, for extension purposes).
  $access = content_moderation_node_type_moderated($node->type);
  backdrop_alter('content_moderation_node_moderated', $access, $node);
  return $access;
}

/**
 * Lists content types that are moderated
 *
 * @return array
 *   List of content types that are moderated.
 */
function content_moderation_moderate_node_types() {
  $types = node_type_get_types();
  $result = array();
  foreach ($types as $type) {
    // Is this content even in moderation?
    if (content_moderation_node_type_moderated($type->type)) {
      $result[] = $type->type;
    }
  }
  return $result;
}

/**
 * Checks if a user may change the state of a node.
 *
 * This check is based on transition and node type. Users
 * with the 'bypass content moderation' permission may make any state
 * transition.
 *
 * @see content_moderation_permission()
 *
 * Note that we do not use content-type specific moderation by default. To
 * enable that, see the instructions in content_moderation_permission().
 *
 * @param User|AnonymousUser|object|null $account
 *   The user account being checked.
 * @param string $from_state
 *   The original moderation state.
 * @param string $to_state
 *   The new moderation state.
 *
 * @return bool
 *   TRUE or FALSE.
 */
function content_moderation_state_allowed($account, $from_state, $to_state, $node_type) {
  // Allow super-users to moderate all content.
  if (user_access("bypass content moderation", $account)) {
    return TRUE;
  }

  // Can this user moderate all content for this transition?
  if (user_access("moderate content from $from_state to $to_state", $account)) {
    return TRUE;
  }

  // Are we using complex node type rules for this transition?
  if (settings_get('content_moderation_per_node_type', FALSE) && user_access("moderate $node_type state from $from_state to $to_state", $account)) {
    return TRUE;
  }

  // Default return.
  return FALSE;
}

/**
 * Adds current and live revision data to a node.
 *
 * @param Node $node
 *   The node being acted upon.
 */
function content_moderation_node_data(Node $node) {
  // Make sure that this node type is moderated.
  if (!content_moderation_node_type_moderated($node->type)) {
    return;
  }

  // Path module is stupid and doesn't load its data in node_load.
  if (module_exists('path') && isset($node->nid)) {
    $path = array();
    $conditions = array('source' => 'node/' . $node->nid);
    $langcode = $node->langcode;
    if ($langcode != LANGUAGE_NONE) {
      $conditions['language'] = $langcode;
    }

    $path = path_load($conditions);
    if ($path === FALSE) {
      $path = array();
    }
    if (isset($node->path)) {
      $path += $node->path;
    }
    $path += array(
      'pid' => NULL,
      'source' => 'node/' . $node->nid,
      'alias' => '',
      'language' => isset($node->langcode) ? $node->langcode : LANGUAGE_NONE,
    );

    $node->path = $path;
  }

  // Build a default 'current' moderation record. Nodes will lack a
  // content_moderation record if moderation was not enabled for their node
  // type when they were created. In that case, assume the live node is at the
  // active revision.
  $defaults = array(
    'hid' => NULL,
    'nid' => $node->nid,
    'vid' => $node->vid,
    'from_state' => content_moderation_state_none(),
    'state' => ($node->status ? content_moderation_state_published() : content_moderation_state_none()),
    'uid' => $node->uid,
    'stamp' => $node->changed,
    'published' => $node->status,
    'is_current' => 1,
  );

  // We'll store moderation state information in an array on the node.
  $node->content_moderation = array();

  // Fetch the most active revision from the {node_revision} table. This is the
  // active revision ("head").
  $query = db_select('node_revision', 'r');
  $query->addJoin('LEFT OUTER', 'content_moderation_node_history', 'm', 'r.vid = %alias.vid');
  $query->condition('r.nid', $node->nid)
    ->condition('m.is_current', 1)
    ->fields('m')
    ->fields('r', array('title', 'timestamp'));
  $current = $query->execute()->fetchObject();

  if (!$current) {
    $current = (object) $defaults;
  }
  else {
    // Fill in any defaults that are missing from the database record. We need
    // to maintain false-y values except for NULL, so array_filter() +
    // array_merge() wouldn't work here.
    foreach (array_keys($defaults) as $key) {
      if (is_null($current->$key)) {
        $current->$key = $defaults[$key];
      }
    }
  }

  $current->is_current = 1;
  $node->content_moderation['current'] = $current;

  // Fetch the published revision. There may not be a content_moderation
  // record for some nodes, but in those cases if the node is published,
  // $current->published will be TRUE.
  if ($current->published) {
    $published = $current;
  }
  else {
    // Fetch the most recent published revision.
    $query = db_select('node', 'n');
    $query->addJoin('INNER', 'node_revision', 'r', 'n.vid = r.vid');
    $query->addJoin('LEFT OUTER', 'content_moderation_node_history', 'm', 'r.vid = m.vid');
    $query->condition('n.nid', $node->nid)
      ->condition('n.status', 1)
      ->orderBy('m.hid', 'DESC')
      ->fields('r', array('nid', 'vid', 'title', 'timestamp'))
      ->fields('m');
    $published = $query->execute()->fetchObject();
  }
  // If we have a published copy, add that to the array.
  if ($published) {
    $published->state = content_moderation_state_published();
    $node->content_moderation['published'] = $published;
  }

  // Fetch the content_moderation record for this node object's revision. If
  // it is either the current or published revision of the node, that data will
  // be used.
  if ($node->vid == $current->vid) {
    $my_revision = $current;
  }
  elseif ($published && $node->vid == $published->vid) {
    $my_revision = $published;
  }
  else {
    $query = db_select('node_revision', 'r');
    $query->addJoin('LEFT OUTER', 'content_moderation_node_history', 'm', 'r.vid = m.vid');
    $query->condition('m.vid', $node->vid)
      ->orderBy('m.hid', 'DESC')
      ->fields('m')
      ->fields('r', array('nid', 'vid', 'title', 'timestamp'));
    $my_revision = $query->execute()->fetchObject();

    // This might happen if you're turning content_moderation on and off, but
    // it should be really rare. Content_moderation must have recorded a
    // active revision, and then the node table must contain a different and
    // unpublished revision.
    if (!$my_revision) {
      $my_revision = (object) array(
        'hid' => NULL,
        'nid' => $node->nid,
        'vid' => $node->vid,
        'from_state' => content_moderation_state_none(),
        'state' => content_moderation_state_none(),
        'uid' => $node->uid,
        'stamp' => $node->changed,
        'published' => 0,
        'is_current' => 0,
      );
    }
  }
  // Add my revision to the array.
  $node->content_moderation['my_revision'] = $my_revision;
}

/**
 * Utility function to load the active revision of a node.
 *
 * @param Node $node
 *   The node being acted upon.
 *
 * @return Node
 *   The current node according to moderation.
 */
function content_moderation_node_current_load(Node $node) {
  // Is there a active revision?
  if (isset($node->content_moderation['current']->vid)) {
    // Ensure that we will return the active revision.
    if ($node->vid != $node->content_moderation['current']->vid) {
      $node = node_load($node->nid, $node->content_moderation['current']->vid);
    }
  }
  return $node;
}

/**
 * Utility function to load the live revision of a node.
 *
 * This is encapsulated so that changes to how the moderation data is stored
 * will not impact the API.
 *
 * @param Node $node
 *   The node being acted upon.
 *
 * @return Node|null
 *   The node object of the live revision.
 */
function content_moderation_node_live_load(Node $node) {
  // Is there a live revision of this node?
  if (isset($node->content_moderation['published']->vid)) {
    return node_load($node->nid, $node->content_moderation['published']->vid);
  }
  return NULL;
}

/**
 * Utility function to determine if this node is in the live state.
 *
 * @param Node $node
 *   The node being acted upon.
 *
 * @return bool
 *   TRUE if this is the active revision. FALSE if not.
 */
function content_moderation_node_is_current(Node $node) {
  if (isset($node->content_moderation['published']->vid) && isset($node->content_moderation['current']->vid)) {
    if ($node->content_moderation['published']->vid == $node->content_moderation['current']->vid) {
      return TRUE;
    }
    return FALSE;
  }
  // If not set, then TRUE.
  return TRUE;
}

/**
 * Get a list of all moderation states.
 *
 * @return array
 *   An array of state arrays, keyed by state name and ordered by weight. Each
 *   state object has name, description, and weight properties.
 */
function content_moderation_states() {
  $states = &backdrop_static(__FUNCTION__);
  if (!isset($states)) {
    $config = config('content_moderation.states');
    $states = $config->getData();
  }

  return $states;
}

/**
 * Generate an array of moderation states suitable for use as Form API #options.
 *
 * @return array
 *   An array of states with machine names as keys and labels as values.
 */
function content_moderation_state_labels() {
  $labels = &backdrop_static(__FUNCTION__);

  if (!isset($labels)) {
    $labels = array();
    foreach (content_moderation_states() as $machine_name => $state) {
      if (module_exists('i18n_string')) {
        $labels[$machine_name] = i18n_string_translate(array(
          'content_moderation',
          'moderation_state',
          $machine_name,
          'label',
        ), $state['label']);
      }
      else {
        $labels[$machine_name] = $state['label'];
      }
    }
  }

  return $labels;
}

/**
 * Implements hook_i18n_string_info().
 */
function content_moderation_i18n_string_info() {
  $groups['content_moderation'] = array(
    'title' => t('Content moderation'),
    'description' => t('Translatable content moderation states: label.'),
    // This group doesn't have strings with format.
    'format' => FALSE,
    // This group can list all strings.
    'list' => TRUE,
  );
  return $groups;
}

/**
 * Implements hook_i18n_string_list().
 */
function content_moderation_i18n_string_list($group) {
  $strings = array();

  if ($group == 'content_moderation') {
    foreach (content_moderation_states() as $state) {
      $strings['content_moderation']['moderation_state'][$state->name]['label'] = $state->label;
      $strings['content_moderation']['moderation_state'][$state->name]['description'] = $state->description;
    }
  }

  return $strings;
}

/**
 * Get the label for a state based on its machine name.
 *
 * @param string $machine_name
 *   The machine name of the state.
 * @return string
 *   An unsanitized label or an empty string if the state does not exist.
 */
function content_moderation_state_label($machine_name) {
  $labels = content_moderation_state_labels();
  return isset($labels[$machine_name]) ? $labels[$machine_name] : '';
}

/**
 * Get information about a single moderation state.
 *
 * @param string $machine_name
 *   The machine name of the state.
 * @return array
 *   An object of information about the state or FALSE if the state does not
 *   exist.
 */
function content_moderation_state_load($machine_name) {
  $states = content_moderation_states();
  if (isset($states[$machine_name])) {
    return $states[$machine_name];
  }
  return FALSE;
}

/**
 * Get information about a single moderation state.
 *
 * @param string $machine_name
 *   The machine name of the state.
 * @return array
 *   An array of information about the state or FALSE if the state does not
 *   exist.
 */
function content_moderation_transition_load($machine_name) {
  $transitions = content_moderation_transitions();
  if (isset($transitions[$machine_name])) {
    return $transitions[$machine_name];
  }
  return FALSE;
}

/**
 * Save a new or existing moderation state.
 *
 * Moderation state names must be unique, so saving a state array with a
 * non-unique name updates the existing state.
 *
 * Invokes hook_content_moderation_state_save().
 *
 * @param array $state
 *   An array with name, description, and weight properties.
 *
 * @see hook_content_moderation_state_save()
 */
function content_moderation_state_save(array $state) {
  $config = config('content_moderation.states');
  $config->set($state['name'], $state);
  $config->save();

  foreach (module_implements('content_moderation_state_save') as $module) {
    // Don't call this function! That would lead to infinite recursion.
    if ($module !== 'content_moderation') {
      module_invoke($module, 'content_moderation_state_save', $state);
    }
  }
}

/**
 * Delete a moderation state.
 *
 * This function also deletes any transitions that reference the deleted
 * moderation state.
 *
 * Invokes hook_content_moderation_state_delete().
 *
 * @param array $state
 *   An array with at least a name property.
 *
 * @see hook_content_moderation_state_delete()
 * @see hook_content_moderation_transition_delete()
 */
function content_moderation_state_delete(array $state) {
  foreach (module_implements('content_moderation_state_delete') as $module) {
    // Don't call this function! That would lead to infinite recursion.
    if ($module !== 'content_moderation') {
      module_invoke($module, 'content_moderation_state_delete', $state);
    }
  }

  $config_states = config('content_moderation.states');
  $config_states->clear($state['name'], $state);
  $config_states->save();

  $config_transitions = config('content_moderation.transitions');
  $transitions = $config_transitions->getData();
  foreach($transitions as $transition) {
    if ($transition['from_name'] == $state['name'] || $transition['to_name'] == $state['name']) {
      content_moderation_transition_delete($transition);
    }
  }

}

/**
 * Get a list of all moderation state transitions.
 *
 * @return array
 *   An array of transition objects, each with from_name and to_name properties
 *   that reference moderation states. The array is ordered by the weight of the
 *   'from' states, then by the weight of the 'to' states.
 */
function content_moderation_transitions() {
  $transitions = &backdrop_static(__FUNCTION__);
  if (!isset($transitions)) {
    $config = config('content_moderation.transitions');
    $transitions = $config->getData();
  }
  return $transitions;
}

/**
 * Saves a moderation state transition.
 *
 * Invokes hook_content_moderation_transition_save().
 *
 * @param array $transition
 *   An array with from_name and to_name properties that reference moderation
 *   states.
 *
 * @see hook_content_moderation_transition_save()
 */
function content_moderation_transition_save(array $transition) {
  $config = config('content_moderation.transitions');
  $config->set($transition['name'], $transition);
  $config->save();

  foreach (module_implements('content_moderation_transition_save') as $module) {
    // Don't call this function! That would lead to infinite recursion.
    if ($module !== 'content_moderation') {
      module_invoke($module, 'content_moderation_transition_save', $transition);
    }
  }

}

/**
 * Deletes a moderation state transition.
 *
 * Invoke hook_content_moderation_transiton_delete().
 *
 * @param array $transition
 *   An array with from_name and to_name properties that reference moderation
 *   states.
 *
 * @see hook_content_moderation_transition_delete()
 */
function content_moderation_transition_delete(array $transition) {
  foreach (module_implements('content_moderation_transition_delete') as $module) {
    // Don't call this function! That would lead to infinite recursion.
    if ($module !== 'content_moderation') {
      module_invoke($module, 'content_moderation_transition_delete', $transition);
    }
  }

  $config_transitions = config('content_moderation.transitions');
  $config_transitions->clear($transition['name']);
  $config_transitions->save();
}

/**
 * Provides a list of possible next states for this node.
 *
 * This function is used in permissions checks, so it should never return
 * disallowed transitions.
 *
 * @param string $current_state
 *   The current moderation state.
 * @param User|AnonymousUser|object|null $account
 *   The user object being checked.
 * @param Node $node
 *   The node object being acted upon.
 *
 * @return array
 *   If the user may moderate a change, return an array of possible state
 *   changes. Otherwise, return FALSE.
 */
function content_moderation_states_next($current_state, $account, Node $node) {
  $states = FALSE;

  // Make sure we have a current state.
  if (!$current_state) {
    $current_state = content_moderation_state_none();
  }

  if (empty($account)) {
    $account = $GLOBALS['user'];
  }

  if (user_access('bypass content moderation', $account)) {
    // Some functions expect an array of $state => $state pairs.
    $states = content_moderation_state_labels();
    unset($states[$current_state]);
  }
  else {
    $config_transitions = config('content_moderation.transitions');
    $transitions = $config_transitions->getData();
    foreach ($transitions as $t) {
      if ($t['from_name'] == $current_state) {
        $transition = $t;
      }
    }
    $config_states = config('content_moderation.states');
    $states = $config_states->getData();
    foreach ($states as $s) {
      if ($s['name'] != $transition['to_name']) {
        unset($states[$s['name']]);
      }
    }

    // Checks whether the user has permission to make each transition. The
    // 'bypass content moderation' permission is accounted for in
    // content_moderation_state_allowed().
    if ($states) {
      foreach ($states as $machine_name => $label) {
        if (!content_moderation_state_allowed($account, $current_state, $machine_name, $node->type)) {
          unset($states[$machine_name]);
        }
      }
    }
  }

  $context = array('account' => $account, 'node' => $node);
  backdrop_alter('content_moderation_states_next', $states, $current_state, $context);
  return $states;
}

/**
 * Provide quick moderation of nodes.
 *
 * Access is controlled by the menu router to these pseudo-form callbacks.
 * This function is also abstracted so that it can be called from any node
 * context.
 *
 * @see _content_moderation_moderate_access()
 * @see content_moderation_menu()
 * @see content_moderation_node_update()
 *
 * @param Node $node
 *   The node being acted upon.
 * @param string $state
 *   The new moderation state requested.
 */
function content_moderation_moderate(Node $node, $state) {
  // Set the current and new moderation state value.
  $node->original = $node;

  // Ensure that published nodes are flagged properly.
  if ($state == content_moderation_state_published()) {
    $node->status = NODE_PUBLISHED;
  }
  // If the published version is being unpublished, account for that.
  elseif (isset($node->content_moderation['published']) && $node->content_moderation['published']->vid == $node->vid) {
    $node->status = NODE_NOT_PUBLISHED;
  }

  // Set the state property for saving.
  $node->content_moderation_state_new = $state;

  // Save the node.
  node_save($node);
}

/**
 * Helper function to redirect after a state change submission.
 *
 * @param Node $node
 *   The node being acted upon.
 * @param string $state
 *   The new moderation state requested.
 */
function content_moderation_moderate_callback(Node $node, $state) {
  if (!isset($_GET['token']) || !backdrop_valid_token($_GET['token'], "{$node->nid}:{$node->vid}:$state")) {
    return MENU_ACCESS_DENIED;
  }

  content_moderation_moderate($node, $state);
  backdrop_goto(isset($_GET['destination']) ? $_GET['destination'] : 'node/' . $node->nid . '/moderation');
}

/**
 * Generates a list of links to available moderation actions.
 *
 * @param Node $node
 *   The node being acted upon.
 * @param array $url_options
 *   An array of options to pass, following the url() function syntax.
 *
 * @return array
 *   A list of links to display with the revision.
 */
function content_moderation_get_moderation_links(Node $node, array $url_options = array()) {
  // Make sure that this node is moderated.
  if (!content_moderation_node_moderated($node)) {
    return;
  }

  // Build links to available moderation states.
  $links = array();
  $my_revision = $node->content_moderation['my_revision'];
  if ($my_revision->vid == $node->content_moderation['current']->vid
      && $next_states = content_moderation_states_next($my_revision->state, NULL, $node)) {
    foreach ($next_states as $state => $label) {
      $link = array_merge($url_options, array(
        'title' => t('Change to %label', array('%label' => content_moderation_state_label($state))),
        'href' => "node/{$node->nid}/moderation/{$node->vid}/change-state/{$state}",
      ));
      $link['query']['token'] = backdrop_get_token("{$node->nid}:{$node->vid}:{$state}");
      $links[] = $link;
    }
  }

  return $links;
}

/**
 * Generates a moderation form for a node.
 *
 * The caller of this form needs to check whether the node is in moderation.
 *
 * @param Node $node
 *   The node being acted upon.
 *
 * @return array
 *   A Backdrop Forms API array.
 */
function content_moderation_moderate_form($form, &$form_state, Node $node, $destination = NULL) {
  global $user;
  $form = array();

  // Build links to available moderation states.
  $links = array();
  $my_revision = $node->content_moderation['my_revision'];
  if ($my_revision->vid == $node->content_moderation['current']->vid
      && $next_states = content_moderation_states_next($my_revision->state, $user, $node)) {
    $form['#destination'] = $destination;
    $form['node'] = array(
      '#type' => 'value',
      '#value' => $node,
    );
    $form['#attributes']['class'][] = 'content-moderation-moderate-form';
    $form['#attached']['css'][] = backdrop_get_path('module', 'content_moderation') . '/css/content_moderation.css';
    $form['state'] = array(
      '#type' => 'select',
      '#title' => t('Moderation state'),
      '#title_display' => 'invisible',
      '#options' => $next_states,
      '#default_value' => _content_moderation_default_next_state($my_revision->state, $next_states),
    );
    $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Apply'),
    );

    // Cache the form on first load to preserve the node for validation.
    // Otherwise, the node would be reloaded on submit, and there would be no
    // way to detect if the active revision has been changed.
    $form_state['cache'] = TRUE;
  }
  else {
    $form['#access'] = FALSE;
  }

  return $form;
}

/**
 * Default next state
 *
 * @param string $current_state
 *   The current state.
 * @param array $next_states
 *   List of the next states.
 */
function _content_moderation_default_next_state($current_state, array $next_states) {
  $states = content_moderation_states();
  foreach ($states as $state_name => $state) {
    if ($state['weight'] > $states[$current_state]['weight'] && isset($next_states[$state_name])) {
      return $state_name;
    }
  }
}

/**
 * Validation handler
 *
 * @see content_moderation_moderate_form()
 */
function content_moderation_moderate_form_validate($form, &$form_state) {
  // Make sure that the revision that was shown to the user is still the current
  // revision before changing the active revision's state.
  $moderated_node = $form_state['values']['node'];
  $current_node = content_moderation_node_current_load(node_load($moderated_node->nid));
  if ($moderated_node->vid != $current_node->vid) {
    form_set_error('', t('The moderation state could not be changed because the draft has been updated by another user. Please review the current draft.'));
    // Redirect the form so that it rebuilds with the active revision.
    backdrop_redirect_form($form_state);
  }
}

/**
 * Submit handler
 *
 * @see content_moderation_moderate_form()
 */
function content_moderation_moderate_form_submit($form, &$form_state) {
  if (_content_moderation_moderate_access($form_state['values']['node'], $form_state['values']['state'])) {
    content_moderation_moderate(node_load($form_state['values']['node']->nid, $form_state['values']['node']->vid), $form_state['values']['state']);
  }

  // This is not ideal, but if the form is invoked from a node's draft tab and
  // used to publish the node, the draft tab will not be available after
  // publishing, and Backdrop's will throw an access denied error before it is
  // able to redirect to the published revision.
  if (!empty($form['#destination'])) {
    if ($form_state['values']['state'] == content_moderation_state_published()) {
      if ($uri = entity_uri('node', $form['node']['#value'])) {
        // Disable lookup of the path alias, since the path alias might get
        // changed by modules such as Pathauto.
        $uri['options']['alias'] = TRUE;
        $form_state['redirect'] = array($uri['path'], $uri['options']);
      }
    }
    else {
      $form_state['redirect'] = $form['#destination'];
    }
  }
}

/**
 * Sets status messages for a node.
 *
 * Note that these status messages aren't relevant to the session, only the
 * current page view.
 *
 * @see content_moderation_set_message()
 *
 * @param string $context
 *   Either 'view' or 'edit'.
 * @param Node|null $node
 *   A node object or NULL. The current menu object will be used if it is a node
 *   and this variable was not set.
 */
function content_moderation_messages($context, Node $node = NULL) {
  global $user;
  static $content_moderation_messages_set;

  if (!user_access('view moderation messages')
      || (!$node && !($node = menu_get_object()))
      || !content_moderation_node_type_moderated($node->type)
      || $content_moderation_messages_set) {
    return;
  }

  $node_published = FALSE;
  $revision_published = FALSE;
  $revision_current = FALSE;
  $content_moderation_messages_set = TRUE;

  // For new content, this property will not be set.
  if (isset($node->content_moderation)) {
    $state = $node->content_moderation;
    if (!empty($state['published'])) {
      $node_published = TRUE;
    }
    if ($state['my_revision']->published) {
      $revision_published = TRUE;
    }
    if ($state['my_revision']->vid == $state['current']->vid) {
      $revision_current = TRUE;
    }
  }

  // An array of messages to add to the general content block.
  $info_block_messages = array();

  if ($context == 'view') {
    if (content_moderation_messages_shown($context, $node)) {
      // Prevent multiple moderation status.
      return;
    }
    $info_block_messages[] = array(
      'label' => t('Revision state'),
      'message' => check_plain(content_moderation_state_label($state['my_revision']->state)),
    );
    $info_block_messages[] = array(
      'label' => t('Most recent revision'),
      'message' => !empty($revision_current) ? t('Yes') : t('No'),
    );

    // Check node access.
    backdrop_static('_node_revision_access', array(), TRUE);

    // Add a moderation form.
    if ($revision_current && !$revision_published && _content_moderation_access('update', $node) && $moderate_form = backdrop_get_form('content_moderation_moderate_form', $node, "node/{$node->nid}/active-revision")) {
      if ($moderate_form = backdrop_render($moderate_form)) {
        $info_block_messages[] = array(
          'label' => t('Set moderation state'),
          'message' => $moderate_form,
        );
      }
    }

    // Add an unpublish link.
    $next_states = content_moderation_states_next(content_moderation_state_published(), $user, $node);
    if ($revision_published && !empty($next_states) && $link = content_moderation_access_link(t('Unpublish this revision'), "node/{$node->nid}/moderation/{$node->vid}/unpublish")) {
      $info_block_messages[] = array(
        'label' => t('Actions'),
        'message' => $link,
      );
    }

    // Revision navigation links. This is disabled for the time being, since
    // node tabs are lost when navigating through old revisions.
    // @TODO remove this entirely?
    if (settings_get('content_moderation_show_revision_navigation', FALSE) && user_access('view revisions')) {
      $links = array();

      // Get previous and next revision ids.
      $args = array(':nid' => $node->nid, ':vid' => $node->vid);
      if ($prev_vid = db_query_range("SELECT nr.vid FROM {node_revision} nr WHERE nr.nid = :nid AND nr.vid < :vid ORDER BY nr.vid DESC", 0, 1, $args)->fetchField()) {
        $links[$prev_vid] = array(
          'title' => t('Previous revision'),
          'href' => "node/{$node->nid}/revisions/{$prev_vid}/view",
        );
      }
      if ($next_vid = db_query_range("SELECT nr.vid FROM {node_revision} nr WHERE nr.nid = :nid AND nr.vid > :vid ORDER BY nr.vid ASC", 0, 1, $args)->fetchField()) {
        $links[$next_vid] = array(
          'title' => t('Next revision'),
          'href' => "node/{$node->nid}/revisions/{$next_vid}/view",
        );
      }

      // If the active revision is next or previous, use the
      // "node/%node/active-revision" path.
      if (($current = $state['current']->vid) && isset($links[$current])) {
        $links[$current]['href'] = "node/{$node->nid}/active-revision";
      }

      // If the published revision is next or previous, use the "node/%node"
      // path.
      if (isset($state['published']) && ($published = $state['published']->vid) && isset($links[$published])) {
        $links[$published]['href'] = "node/{$node->nid}";
      }

      // Link it up, with access checks.
      foreach ($links as $key => $args) {
        $links[$key] = call_user_func_array('content_moderation_access_link', $args);
      }

      // Post the links in a non-repeating message.
      if (!empty($links)) {
        $info_block_messages[] = array(
          'label' => t('View'),
          'message' => implode(', ', $links),
        );
      }
    }
  }
  // @TODO: Clean these up.
  elseif ($context == 'edit') {
    if ($node_published && $revision_published) {
      $info_block_messages[] = array(
        'label' => t('Status'),
        'message' => t('New draft of live content.'),
      );
    }
    elseif ($node_published && !$revision_published) {
      $info_block_messages[] = array(
        'label' => t('Status'),
        'message' => t('New draft from active revision'),
      );
      $link = content_moderation_access_link(t('Create a new draft from the published revision.'), "node/{$node->nid}/revisions/{$state['published']->vid}/revert");
      $info_block_messages[] = array(
        'label' => t('Actions'),
        'message' => $link,
      );
    }
    else {
      // New content.
      $info_block_messages[] = array(
        'label' => t('New content'),
        'message' => t('Your draft will be placed in moderation.'),
      );
    }
  }

  // Send the info block array to a static variable.
  content_moderation_set_message($info_block_messages);
}

/**
 * Prevent multiple moderation status.
 *
 * This function is a helper called from content_moderation_messages(). If the
 * same node node_view() called multiple times in a page request there could be
 * duplicate messages.
 *
 * @param string $context
 *   Either 'view' or 'edit'. Currently only "view" is implemented.
 * @param Node $node
 *   A node object for which content_moderation_messages() is adding messages.
 * @return bool
 *   TRUE or FALSE for whether the given node has had messages added in the
 *   given context.
 */
function content_moderation_messages_shown($context, Node $node) {
  $shown = &backdrop_static(__FUNCTION__);
  if (!empty($shown[$context][$node->nid])) {
    return TRUE;
  }
  $shown[$context][$node->nid] = TRUE;
  return FALSE;
}

/**
 * Builds a link for use in messages.
 *
 * @see content_moderation_messages()
 *
 * @param string $text
 *   The link text to use.
 * @param string $internal_path
 *   The Backdrop path for the link.
 * @param array $options
 *   Link options, following the format of url().
 *
 * @return string
 *   A Backdrop-formatted HTML link.
 */
function content_moderation_access_link($text, $internal_path, array $options = array()) {
  if (($item = menu_get_item($internal_path)) && !empty($item['access'])) {
    return l($text, $internal_path, $options);
  }
  return '';
}

/**
 * Stores status messages for delivery.
 *
 * This function stores up moderation messages to be passed on to
 * content_moderation_block_view().
 *
 * This function uses a static variable so that function can be called more than
 * once and the array built up.
 *
 * @see content_moderation_block_view()
 * @see content_moderation_messages()
 *
 * @param array $new_messages
 *   An array of messages to be added to the block.
 *
 * @return array
 *   An array of messages to be added to the block.
 */
function content_moderation_set_message(array $new_messages = array()) {
  static $messages = array();
  $messages = array_merge($messages, $new_messages);
  return $messages;
}

/**
 * Implements hook_block_info().
 */
function content_moderation_block_info() {
  $blocks['content_moderation_status'] = array(
    'info' => t('Content moderation status'),
    'description' => t('Display content moderation status and moderation form. Only available when a node context is available'),
    'required contexts' => array('node' => 'node'),
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 *
 * Show the editorial status of this node.
 */
function content_moderation_block_view($delta = '', $settings = array(), $contexts = array()) {
  if ($delta != 'content_moderation_status') {
    return;
  }
  $block['subject'] = t('Content moderation status');

  $items = array();
  foreach (content_moderation_set_message() as $message) {
    $items[] = t('!label: <em>!message</em>', array(
      '!label' => $message['label'],
      '!message' => $message['message'],
    ));
  }

  $block['content'] = array(
    '#markup' => theme('container', array('element' => array(
      '#children' => implode('<br/>', $items),
      '#attributes' => array('class' => 'content-moderation-status'),
    ))),
    '#attached' => array(
      'css' => array(backdrop_get_path('module', 'content_moderation') . '/css/content_moderation.css'),
    ),
  );

  return $block;
}

/**
 * Implements hook_content_moderation_transition().
 */
function content_moderation_content_moderation_transition($node, $previous_state, $new_state) {
  if (module_exists('trigger')) {
    content_moderation_trigger_transition($node, $previous_state, $new_state);
  }

  if (module_exists('rules')){
    rules_invoke_event('content_moderation_after_moderation_transition', $node, $previous_state, $new_state);
  }
}

/**
 * Implements hook_trigger_info().
 *
 * Creates a trigger for each transition.
 */
function content_moderation_trigger_info() {

  $output = array(
    'content_moderation' => array(
      'content_moderation_transition' => array(
        'label' => t('After any transition between states occurs.'),
      ),
    ),
  );

  // Get all transitions.
  $transitions = content_moderation_transitions();

  // Add a trigger for each transition.
  foreach ($transitions as $transition_definition) {
    $transition_string = 'wmt_' . $transition_definition['from_name'] . '__' . $transition_definition['to_name'];
    // Hash this string if it's longer than the db field size.
    if (strlen($transition_string) > 32) {
      $transition_string = md5($transition_string);
    }

    $output['content_moderation'][$transition_string] = array(
      'label' => t('Transition from the state %from_name to %to_name occurs.', array(
        '%from_name' => $transition_definition['from_name'],
        '%to_name' => $transition_definition['to_name'],
      )),
    );
  }

  return $output;
}

/**
 * Transition trigger: Run actions associated with an arbitrary event.
 *
 * This function is executed after a transition takes place.
 *
 * @param Node $node
 *   The node undergoing the transition.
 * @param string $from_state
 *   The previous content moderation state.
 * @param string $state
 *   The new content moderation state.
 */
function content_moderation_trigger_transition(Node $node, $from_state, $state, $a3 = NULL, $a4 = NULL) {
  // Ask the trigger module for all actions enqueued for the 'transition'
  // trigger.
  $aids = trigger_get_assigned_actions('content_moderation_transition');
  // Prepare a basic context, indicating group and "hook", and call all the
  // actions with this context as arguments.
  $context = array(
    'group' => 'content_moderation',
    'hook' => 'transition',
    'from_state' => $from_state,
    'state' => $state,
  );
  actions_do(array_keys($aids), $node, $context, $a3, $a4);

  // Ask the trigger module for all actions enqueued for this specific
  // transition.
  $transition_string = 'wmt_' . $from_state . '__' . $state;
  // Hash this string if it's longer than the db field size.
  if (strlen($transition_string) > 32) {
    $transition_string = md5($transition_string);
  }
  $aids = trigger_get_assigned_actions($transition_string);
  $context['hook'] = $transition_string;

  actions_do(array_keys($aids), $node, $context, $a3, $a4);
}

/**
 * Implements hook_action_info().
 */
function content_moderation_action_info() {
  $info = array();
  $info['content_moderation_set_state_action'] = array(
    'type' => 'node',
    'label' => t('Set moderation state'),
    'configurable' => TRUE,
    'triggers' => array(
      'node_presave',
      'node_insert',
      'node_update',
      'content_moderation_transition',
    ),
  );

  // Get all content transitions.
  $transitions = content_moderation_transitions();

  // Add a trigger for each transition.
  foreach ($transitions as $transition_definition) {
    $transition_string = 'wmt_' . $transition_definition['from_name'] . '__' . $transition_definition['to_name'];
    // Hash this string if it's longer than the db field size.
    if (strlen($transition_string) > 32) {
      $transition_string = md5($transition_string);
    }

    $info['content_moderation_set_state_action']['triggers'][] = $transition_string;
  }

  return $info;
}

/**
 * Form builder.
 * Prepare a form for possible moderation states.
 */
function content_moderation_set_state_action_form($context) {
  $form = array();

  $form['state'] = array(
    '#type' => 'select',
    '#options' => content_moderation_state_labels(),
    '#default_value' => isset($context['state']) ? $context['state'] : '',
  );

  return $form;
}

/**
 * Process content_moderation_set_state_action_form form submissions.
 */
function content_moderation_set_state_action_submit($form, $form_state) {
  return array('state' => $form_state['values']['state']);
}

/**
 * Changes the moderation state for a given node.
 */
function content_moderation_set_state_action(Node $node, $context) {
  if (empty($context['state'])) return;

  // Check access to perform this moderation, on the latest revision of the
  // node.
  $node = content_moderation_node_current_load($node);
  if (_content_moderation_moderate_access($node, $context['state'])) {
    $node->content_moderation_state_new = $context['state'];
    $node->revision = 1;
    $node->log = "Bulk moderation state change.";
    node_save($node);

    watchdog('action', 'Change node %nid moderation state to %state.', array(
      '%nid' => $node->nid,
      '%state' => $context['state'],
    ));
  }
  else {
    backdrop_set_message(t('You do not have permission to moderate %node', array('%node' => $node->title)), 'warning');
  }
}

/**
 * Implements hook_migrate_api().
 */
function content_moderation_migrate_api() {
  return array('api' => 2);
}

/**
 * Wrapper for user_access to admin content_moderation.
 */
function content_moderation_transition_access($op, $profile = NULL, $account = NULL) {
  return user_access('administer content moderation');
}

/**
 * Implements hook_node_export_node_alter().
 *
 * Manipulate a node on export.
 *
 * @param Node &$node
 *   The node to alter.
 * @param Node $original_node
 *   The unaltered node.
 */
function content_moderation_node_export_node_alter(Node &$node, Node $original_node) {

  // Don't proceed if moderation is not enabled on this content type.
  if (!content_moderation_node_type_moderated($node->type)) {
    return;
  }

  // Set the current state to be the same as the active revision's state.
  if(!isset($node->content_moderation_state_current) && isset($node->content_moderation) && isset($node->content_moderation['current'])){
    $node->content_moderation_state_current = $node->content_moderation['current']->state;
  }

  // Set default moderation state values if they are not set.
  if (!isset($node->content_moderation_state_current)) {
    $node->content_moderation_state_current = ($node->status ? content_moderation_state_published() : content_moderation_state_none());
  };

  if (isset($node->content_moderation_state_current)) {
    // Set the new state to be the same as the current.
    $node->content_moderation_state_new = $node->content_moderation_state_current;
  }

  // Node revisions will not be exported so remove moderation states tied to
  // revisions.
  unset($node->content_moderation);
}

/**
 * Implements hook_node_export_node_import_alter().
 */
function content_moderation_node_export_node_import_alter(&$node, $original_node, $save) {
  // Don't proceed if moderation is not enabled on this content type.
  if (!content_moderation_node_type_moderated($node->type)) {
    return;
  }
  $node->revision = 1;
}

/**
 * Callback function to delete a single temporary-draft revision.
 *
 * Could be called either from a batch job or from a cron-queue.
 */
function content_moderation_queue_delete_revision($content_moderation_queue_item, &$context = NULL) {
  try {
    // Trigger hook_content_moderation_predelete_revision(). Allow other modules to
    // preserve information on the old revision before it's deleted.
    module_invoke_all('content_moderation_predelete_revision', $content_moderation_queue_item['entity_type'], $content_moderation_queue_item['entity_id'], $content_moderation_queue_item['revision_id'], $content_moderation_queue_item['replaced_by']);

    // Delete the old revision.
    entity_revision_delete($content_moderation_queue_item['entity_type'], $content_moderation_queue_item['revision_id']);

    // Document the successful batch operation for the batch-finished function
    // to use.
    if (!empty($context) && isset($context['results'])){
      $context['results'][] = $content_moderation_queue_item;
    }
  }
  catch (Exception $ex){
    // Log the problem.
    $message = 'An error occurred while deleting temporary revision: @args. Exception details: @error';
    $args = array(
      '@args' => print_r($content_moderation_queue_item, TRUE),
      '@error' => print_r($ex, TRUE),
    );
    watchdog('content_moderation', $message, $args, WATCHDOG_ERROR);
    throw $ex;  // Batch API will pass $success = FALSE.
  }
}

/**
 * Implements hook_cron_queue_info().
 */
function content_moderation_cron_queue_info() {
  $queues['content_moderation_revision_delete'] = array(
    'worker callback' => 'content_moderation_queue_delete_revision',
    'time' => 60,
  );
  return $queues;
}

/**
 * Batch completion callback for when draft-deletes happen in a batch job.
 * $results contains info about successfully deleted revisions, and
 * exception objects for revision-delete options that caused problems.
 * $operations contains the operations that remained unprocessed.
 */
function content_moderation_delete_batch_finished($success, $results, $operations) {
  // TODO: Display a message about temporary-revision-cleanup here?
  // Note that logging of failed deletes is handled by the operation callback.
}


/**
 * Factory function for the ContentModerationDraftTracker class.
 */
function draft_tracker() {
  $tracker = &backdrop_static(__FUNCTION__);
  if (!isset($tracker)) {
    $tracker = new ContentModerationDraftTracker();
  }
  return $tracker;
}
